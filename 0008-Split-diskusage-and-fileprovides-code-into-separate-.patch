From e77926c355afff8be62e401ff3c4446fcbaaace5 Mon Sep 17 00:00:00 2001
From: Michael Schroeder <mls@suse.de>
Date: Thu, 3 Mar 2016 15:08:38 +0100
Subject: [PATCH 7/9] Split diskusage and fileprovides code into separate files

---
 src/CMakeLists.txt |   3 +-
 src/diskusage.c    | 348 +++++++++++++++++++++++++++
 src/fileprovides.c | 373 +++++++++++++++++++++++++++++
 src/pool.c         | 676 -----------------------------------------------------
 4 files changed, 723 insertions(+), 677 deletions(-)
 create mode 100644 src/diskusage.c
 create mode 100644 src/fileprovides.c

diff --git a/src/CMakeLists.txt b/src/CMakeLists.txt
index a2c0098..241890d 100644
--- a/src/CMakeLists.txt
+++ b/src/CMakeLists.txt
@@ -18,7 +18,8 @@ SET (libsolv_SRCS
     solver.c solverdebug.c repo_solv.c repo_write.c evr.c pool.c
     queue.c repo.c repodata.c repopage.c util.c policy.c solvable.c
     transaction.c order.c rules.c problems.c linkedpkg.c cplxdeps.c
-    chksum.c md5.c sha1.c sha2.c solvversion.c selection.c)
+    chksum.c md5.c sha1.c sha2.c solvversion.c selection.c
+    fileprovides.c diskusage.c)
 
 SET (libsolv_HEADERS
     bitmap.h evr.h hash.h policy.h poolarch.h poolvendor.h pool.h
diff --git a/src/diskusage.c b/src/diskusage.c
new file mode 100644
index 0000000..b764b98
--- /dev/null
+++ b/src/diskusage.c
@@ -0,0 +1,348 @@
+/*
+ * Copyright (c) 2007-2016, SUSE LLC
+ *
+ * This program is licensed under the BSD license, read LICENSE.BSD
+ * for further information
+ */
+
+/*
+ * diskusage.c
+ *
+ * calculate needed space on partitions
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdarg.h>
+#include <unistd.h>
+#include <string.h>
+
+#include "pool.h"
+#include "poolarch.h"
+#include "repo.h"
+#include "util.h"
+#include "bitmap.h"
+
+
+struct mptree {
+  Id sibling;
+  Id child;
+  const char *comp;
+  int compl;
+  Id mountpoint;
+};
+
+struct ducbdata {
+  DUChanges *mps;
+  struct mptree *mptree;
+  int addsub;
+  int hasdu;
+
+  Id *dirmap;
+  int nmap;
+  Repodata *olddata;
+};
+
+
+static int
+solver_fill_DU_cb(void *cbdata, Solvable *s, Repodata *data, Repokey *key, KeyValue *value)
+{
+  struct ducbdata *cbd = cbdata;
+  Id mp;
+
+  if (data != cbd->olddata)
+    {
+      Id dn, mp, comp, *dirmap, *dirs;
+      int i, compl;
+      const char *compstr;
+      struct mptree *mptree;
+
+      /* create map from dir to mptree */
+      cbd->dirmap = solv_free(cbd->dirmap);
+      cbd->nmap = 0;
+      dirmap = solv_calloc(data->dirpool.ndirs, sizeof(Id));
+      mptree = cbd->mptree;
+      mp = 0;
+      for (dn = 2, dirs = data->dirpool.dirs + dn; dn < data->dirpool.ndirs; dn++)
+	{
+	  comp = *dirs++;
+	  if (comp <= 0)
+	    {
+	      mp = dirmap[-comp];
+	      continue;
+	    }
+	  if (mp < 0)
+	    {
+	      /* unconnected */
+	      dirmap[dn] = mp;
+	      continue;
+	    }
+	  if (!mptree[mp].child)
+	    {
+	      dirmap[dn] = -mp;
+	      continue;
+	    }
+	  if (data->localpool)
+	    compstr = stringpool_id2str(&data->spool, comp);
+	  else
+	    compstr = pool_id2str(data->repo->pool, comp);
+	  compl = strlen(compstr);
+	  for (i = mptree[mp].child; i; i = mptree[i].sibling)
+	    if (mptree[i].compl == compl && !strncmp(mptree[i].comp, compstr, compl))
+	      break;
+	  dirmap[dn] = i ? i : -mp;
+	}
+      /* change dirmap to point to mountpoint instead of mptree */
+      for (dn = 0; dn < data->dirpool.ndirs; dn++)
+	{
+	  mp = dirmap[dn];
+	  dirmap[dn] = mptree[mp > 0 ? mp : -mp].mountpoint;
+	}
+      cbd->dirmap = dirmap;
+      cbd->nmap = data->dirpool.ndirs;
+      cbd->olddata = data;
+    }
+  cbd->hasdu = 1;
+  if (value->id < 0 || value->id >= cbd->nmap)
+    return 0;
+  mp = cbd->dirmap[value->id];
+  if (mp < 0)
+    return 0;
+  if (cbd->addsub > 0)
+    {
+      cbd->mps[mp].kbytes += value->num;
+      cbd->mps[mp].files += value->num2;
+    }
+  else if (!(cbd->mps[mp].flags & DUCHANGES_ONLYADD))
+    {
+      cbd->mps[mp].kbytes -= value->num;
+      cbd->mps[mp].files -= value->num2;
+    }
+  return 0;
+}
+
+static void
+propagate_mountpoints(struct mptree *mptree, int pos, Id mountpoint)
+{
+  int i;
+  if (mptree[pos].mountpoint == -1)
+    mptree[pos].mountpoint = mountpoint;
+  else
+    mountpoint = mptree[pos].mountpoint;
+  for (i = mptree[pos].child; i; i = mptree[i].sibling)
+    propagate_mountpoints(mptree, i, mountpoint);
+}
+
+#define MPTREE_BLOCK 15
+
+static struct mptree *
+create_mptree(DUChanges *mps, int nmps)
+{
+  int i, nmptree;
+  struct mptree *mptree;
+  int pos, compl;
+  int mp;
+  const char *p, *path, *compstr;
+
+  mptree = solv_extend_resize(0, 1, sizeof(struct mptree), MPTREE_BLOCK);
+
+  /* our root node */
+  mptree[0].sibling = 0;
+  mptree[0].child = 0;
+  mptree[0].comp = 0;
+  mptree[0].compl = 0;
+  mptree[0].mountpoint = -1;
+  nmptree = 1;
+
+  /* create component tree */
+  for (mp = 0; mp < nmps; mp++)
+    {
+      mps[mp].kbytes = 0;
+      mps[mp].files = 0;
+      pos = 0;
+      path = mps[mp].path;
+      while(*path == '/')
+	path++;
+      while (*path)
+	{
+	  if ((p = strchr(path, '/')) == 0)
+	    {
+	      compstr = path;
+	      compl = strlen(compstr);
+	      path += compl;
+	    }
+	  else
+	    {
+	      compstr = path;
+	      compl = p - path;
+	      path = p + 1;
+	      while(*path == '/')
+		path++;
+	    }
+          for (i = mptree[pos].child; i; i = mptree[i].sibling)
+	    if (mptree[i].compl == compl && !strncmp(mptree[i].comp, compstr, compl))
+	      break;
+	  if (!i)
+	    {
+	      /* create new node */
+	      mptree = solv_extend(mptree, nmptree, 1, sizeof(struct mptree), MPTREE_BLOCK);
+	      i = nmptree++;
+	      mptree[i].sibling = mptree[pos].child;
+	      mptree[i].child = 0;
+	      mptree[i].comp = compstr;
+	      mptree[i].compl = compl;
+	      mptree[i].mountpoint = -1;
+	      mptree[pos].child = i;
+	    }
+	  pos = i;
+	}
+      mptree[pos].mountpoint = mp;
+    }
+
+  propagate_mountpoints(mptree, 0, mptree[0].mountpoint);
+
+#if 0
+  for (i = 0; i < nmptree; i++)
+    {
+      printf("#%d sibling: %d\n", i, mptree[i].sibling);
+      printf("#%d child: %d\n", i, mptree[i].child);
+      printf("#%d comp: %s\n", i, mptree[i].comp);
+      printf("#%d compl: %d\n", i, mptree[i].compl);
+      printf("#%d mountpont: %d\n", i, mptree[i].mountpoint);
+    }
+#endif
+
+  return mptree;
+}
+
+void
+pool_calc_duchanges(Pool *pool, Map *installedmap, DUChanges *mps, int nmps)
+{
+  struct mptree *mptree;
+  struct ducbdata cbd;
+  Solvable *s;
+  int i, sp;
+  Map ignoredu;
+  Repo *oldinstalled = pool->installed;
+  int haveonlyadd = 0;
+
+  map_init(&ignoredu, 0);
+  mptree = create_mptree(mps, nmps);
+
+  for (i = 0; i < nmps; i++)
+    if ((mps[i].flags & DUCHANGES_ONLYADD) != 0)
+      haveonlyadd = 1;
+  cbd.mps = mps;
+  cbd.dirmap = 0;
+  cbd.nmap = 0;
+  cbd.olddata = 0;
+  cbd.mptree = mptree;
+  cbd.addsub = 1;
+  for (sp = 1, s = pool->solvables + sp; sp < pool->nsolvables; sp++, s++)
+    {
+      if (!s->repo || (oldinstalled && s->repo == oldinstalled))
+	continue;
+      if (!MAPTST(installedmap, sp))
+	continue;
+      cbd.hasdu = 0;
+      repo_search(s->repo, sp, SOLVABLE_DISKUSAGE, 0, 0, solver_fill_DU_cb, &cbd);
+      if (!cbd.hasdu && oldinstalled)
+	{
+	  Id op, opp;
+	  int didonlyadd = 0;
+	  /* no du data available, ignore data of all installed solvables we obsolete */
+	  if (!ignoredu.size)
+	    map_grow(&ignoredu, oldinstalled->end - oldinstalled->start);
+	  FOR_PROVIDES(op, opp, s->name)
+	    {
+	      Solvable *s2 = pool->solvables + op;
+	      if (!pool->implicitobsoleteusesprovides && s->name != s2->name)
+		continue;
+	      if (pool->implicitobsoleteusescolors && !pool_colormatch(pool, s, s2))
+		continue;
+	      if (op >= oldinstalled->start && op < oldinstalled->end)
+		{
+		  MAPSET(&ignoredu, op - oldinstalled->start);
+		  if (haveonlyadd && pool->solvables[op].repo == oldinstalled && !didonlyadd)
+		    {
+		      repo_search(oldinstalled, op, SOLVABLE_DISKUSAGE, 0, 0, solver_fill_DU_cb, &cbd);
+		      cbd.addsub = -1;
+		      repo_search(oldinstalled, op, SOLVABLE_DISKUSAGE, 0, 0, solver_fill_DU_cb, &cbd);
+		      cbd.addsub = 1;
+		      didonlyadd = 1;
+		    }
+		}
+	    }
+	  if (s->obsoletes)
+	    {
+	      Id obs, *obsp = s->repo->idarraydata + s->obsoletes;
+	      while ((obs = *obsp++) != 0)
+		FOR_PROVIDES(op, opp, obs)
+		  {
+		    Solvable *s2 = pool->solvables + op;
+		    if (!pool->obsoleteusesprovides && !pool_match_nevr(pool, s2, obs))
+		      continue;
+		    if (pool->obsoleteusescolors && !pool_colormatch(pool, s, s2))
+		      continue;
+		    if (op >= oldinstalled->start && op < oldinstalled->end)
+		      {
+			MAPSET(&ignoredu, op - oldinstalled->start);
+			if (haveonlyadd && pool->solvables[op].repo == oldinstalled && !didonlyadd)
+			  {
+			    repo_search(oldinstalled, op, SOLVABLE_DISKUSAGE, 0, 0, solver_fill_DU_cb, &cbd);
+			    cbd.addsub = -1;
+			    repo_search(oldinstalled, op, SOLVABLE_DISKUSAGE, 0, 0, solver_fill_DU_cb, &cbd);
+			    cbd.addsub = 1;
+			    didonlyadd = 1;
+			  }
+		      }
+		  }
+	    }
+	}
+    }
+  cbd.addsub = -1;
+  if (oldinstalled)
+    {
+      /* assumes we allways have du data for installed solvables */
+      FOR_REPO_SOLVABLES(oldinstalled, sp, s)
+	{
+	  if (MAPTST(installedmap, sp))
+	    continue;
+	  if (ignoredu.map && MAPTST(&ignoredu, sp - oldinstalled->start))
+	    continue;
+	  repo_search(oldinstalled, sp, SOLVABLE_DISKUSAGE, 0, 0, solver_fill_DU_cb, &cbd);
+	}
+    }
+  map_free(&ignoredu);
+  solv_free(cbd.dirmap);
+  solv_free(mptree);
+}
+
+int
+pool_calc_installsizechange(Pool *pool, Map *installedmap)
+{
+  Id sp;
+  Solvable *s;
+  int change = 0; 
+  Repo *oldinstalled = pool->installed;
+
+  for (sp = 1, s = pool->solvables + sp; sp < pool->nsolvables; sp++, s++) 
+    {    
+      if (!s->repo || (oldinstalled && s->repo == oldinstalled))
+        continue;
+      if (!MAPTST(installedmap, sp)) 
+        continue;
+      change += solvable_lookup_sizek(s, SOLVABLE_INSTALLSIZE, 0);
+    }    
+  if (oldinstalled)
+    {    
+      FOR_REPO_SOLVABLES(oldinstalled, sp, s)
+        {
+          if (MAPTST(installedmap, sp)) 
+            continue;
+          change -= solvable_lookup_sizek(s, SOLVABLE_INSTALLSIZE, 0);
+        }
+    }    
+  return change;
+}
+
diff --git a/src/fileprovides.c b/src/fileprovides.c
new file mode 100644
index 0000000..11ff4f5
--- /dev/null
+++ b/src/fileprovides.c
@@ -0,0 +1,373 @@
+/*
+ * Copyright (c) 2007-2016, SUSE LLC
+ *
+ * This program is licensed under the BSD license, read LICENSE.BSD
+ * for further information
+ */
+
+/*
+ * fileprovides.c
+ *
+ * Add missing file dependencies to the package provides 
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdarg.h>
+#include <unistd.h>
+#include <string.h>
+
+#include "pool.h"
+#include "repo.h"
+#include "util.h"
+#include "bitmap.h"
+
+struct searchfiles {
+  Id *ids;
+  int nfiles;
+  Map seen;
+};
+
+#define SEARCHFILES_BLOCK 127
+
+static void
+pool_addfileprovides_dep(Pool *pool, Id *ida, struct searchfiles *sf, struct searchfiles *isf)
+{
+  Id dep, sid;
+  const char *s;
+  struct searchfiles *csf;
+
+  while ((dep = *ida++) != 0)
+    {
+      csf = sf;
+      while (ISRELDEP(dep))
+	{
+	  Reldep *rd;
+	  sid = pool->ss.nstrings + GETRELID(dep);
+	  if (MAPTST(&csf->seen, sid))
+	    {
+	      dep = 0;
+	      break;
+	    }
+	  MAPSET(&csf->seen, sid);
+	  rd = GETRELDEP(pool, dep);
+	  if (rd->flags < 8)
+	    dep = rd->name;
+	  else if (rd->flags == REL_NAMESPACE)
+	    {
+	      if (rd->name == NAMESPACE_SPLITPROVIDES)
+		{
+		  csf = isf;
+		  if (!csf || MAPTST(&csf->seen, sid))
+		    {
+		      dep = 0;
+		      break;
+		    }
+		  MAPSET(&csf->seen, sid);
+		}
+	      dep = rd->evr;
+	    }
+	  else if (rd->flags == REL_FILECONFLICT)
+	    {
+	      dep = 0;
+	      break;
+	    }
+	  else
+	    {
+	      Id ids[2];
+	      ids[0] = rd->name;
+	      ids[1] = 0;
+	      pool_addfileprovides_dep(pool, ids, csf, isf);
+	      dep = rd->evr;
+	    }
+	}
+      if (!dep)
+	continue;
+      if (MAPTST(&csf->seen, dep))
+	continue;
+      MAPSET(&csf->seen, dep);
+      s = pool_id2str(pool, dep);
+      if (*s != '/')
+	continue;
+      if (csf != isf && pool->addedfileprovides == 1 && !repodata_filelistfilter_matches(0, s))
+	continue;	/* skip non-standard locations csf == isf: installed case */
+      csf->ids = solv_extend(csf->ids, csf->nfiles, 1, sizeof(Id), SEARCHFILES_BLOCK);
+      csf->ids[csf->nfiles++] = dep;
+    }
+}
+
+struct addfileprovides_cbdata {
+  int nfiles;
+  Id *ids;
+  char **dirs;
+  char **names;
+
+  Id *dids;
+
+  Map providedids;
+
+  Map useddirs;
+};
+
+static int
+addfileprovides_cb(void *cbdata, Solvable *s, Repodata *data, Repokey *key, KeyValue *value)
+{
+  struct addfileprovides_cbdata *cbd = cbdata;
+  int i;
+
+  if (!cbd->useddirs.size)
+    {
+      map_init(&cbd->useddirs, data->dirpool.ndirs + 1);
+      if (!cbd->dirs)
+	{
+	  cbd->dirs = solv_malloc2(cbd->nfiles, sizeof(char *));
+	  cbd->names = solv_malloc2(cbd->nfiles, sizeof(char *));
+	  for (i = 0; i < cbd->nfiles; i++)
+	    {
+	      char *s = solv_strdup(pool_id2str(data->repo->pool, cbd->ids[i]));
+	      cbd->dirs[i] = s;
+	      s = strrchr(s, '/');
+	      *s = 0;
+	      cbd->names[i] = s + 1;
+	    }
+	}
+      for (i = 0; i < cbd->nfiles; i++)
+	{
+	  Id did;
+	  if (MAPTST(&cbd->providedids, cbd->ids[i]))
+	    {
+	      cbd->dids[i] = 0;
+	      continue;
+	    }
+	  did = repodata_str2dir(data, cbd->dirs[i], 0);
+	  cbd->dids[i] = did;
+	  if (did)
+	    MAPSET(&cbd->useddirs, did);
+	}
+      repodata_free_dircache(data);
+    }
+  if (value->id >= data->dirpool.ndirs || !MAPTST(&cbd->useddirs, value->id))
+    return 0;
+  for (i = 0; i < cbd->nfiles; i++)
+    if (cbd->dids[i] == value->id && !strcmp(cbd->names[i], value->str))
+      s->provides = repo_addid_dep(s->repo, s->provides, cbd->ids[i], SOLVABLE_FILEMARKER);
+  return 0;
+}
+
+static void
+pool_addfileprovides_search(Pool *pool, struct addfileprovides_cbdata *cbd, struct searchfiles *sf, Repo *repoonly)
+{
+  Id p;
+  Repodata *data;
+  Repo *repo;
+  Queue fileprovidesq;
+  int i, j, repoid, repodataid;
+  int provstart, provend;
+  Map donemap;
+  int ndone, incomplete;
+
+  if (!pool->urepos)
+    return;
+
+  cbd->nfiles = sf->nfiles;
+  cbd->ids = sf->ids;
+  cbd->dirs = 0;
+  cbd->names = 0;
+  cbd->dids = solv_realloc2(cbd->dids, sf->nfiles, sizeof(Id));
+  map_init(&cbd->providedids, pool->ss.nstrings);
+
+  repoid = 1;
+  repo = repoonly ? repoonly : pool->repos[repoid];
+  map_init(&donemap, pool->nsolvables);
+  queue_init(&fileprovidesq);
+  provstart = provend = 0;
+  for (;;)
+    {
+      if (!repo || repo->disabled)
+	{
+	  if (repoonly || ++repoid == pool->nrepos)
+	    break;
+	  repo = pool->repos[repoid];
+	  continue;
+	}
+      ndone = 0;
+      FOR_REPODATAS(repo, repodataid, data)
+	{
+	  if (ndone >= repo->nsolvables)
+	    break;
+
+	  if (repodata_lookup_idarray(data, SOLVID_META, REPOSITORY_ADDEDFILEPROVIDES, &fileprovidesq))
+	    {
+	      map_empty(&cbd->providedids);
+	      for (i = 0; i < fileprovidesq.count; i++)
+		MAPSET(&cbd->providedids, fileprovidesq.elements[i]);
+	      provstart = data->start;
+	      provend = data->end;
+	      for (i = 0; i < cbd->nfiles; i++)
+		if (!MAPTST(&cbd->providedids, cbd->ids[i]))
+		  break;
+	      if (i == cbd->nfiles)
+		{
+		  /* great! no need to search files */
+		  for (p = data->start; p < data->end; p++)
+		    if (pool->solvables[p].repo == repo)
+		      {
+			if (MAPTST(&donemap, p))
+			  continue;
+			MAPSET(&donemap, p);
+			ndone++;
+		      }
+		  continue;
+		}
+	    }
+
+	  if (!repodata_has_keyname(data, SOLVABLE_FILELIST))
+	    continue;
+
+	  if (data->start < provstart || data->end > provend)
+	    {
+	      map_empty(&cbd->providedids);
+	      provstart = provend = 0;
+	    }
+
+	  /* check if the data is incomplete */
+	  incomplete = 0;
+	  if (data->state == REPODATA_AVAILABLE)
+	    {
+	      for (j = 1; j < data->nkeys; j++)
+		if (data->keys[j].name != REPOSITORY_SOLVABLES && data->keys[j].name != SOLVABLE_FILELIST)
+		  break;
+	      if (j < data->nkeys)
+		{
+#if 0
+		  for (i = 0; i < cbd->nfiles; i++)
+		    if (!MAPTST(&cbd->providedids, cbd->ids[i]) && !repodata_filelistfilter_matches(data, pool_id2str(pool, cbd->ids[i])))
+		      printf("need complete filelist because of %s\n", pool_id2str(pool, cbd->ids[i]));
+#endif
+		  for (i = 0; i < cbd->nfiles; i++)
+		    if (!MAPTST(&cbd->providedids, cbd->ids[i]) && !repodata_filelistfilter_matches(data, pool_id2str(pool, cbd->ids[i])))
+		      break;
+		  if (i < cbd->nfiles)
+		    incomplete = 1;
+		}
+	    }
+
+	  /* do the search */
+	  map_init(&cbd->useddirs, 0);
+	  for (p = data->start; p < data->end; p++)
+	    if (pool->solvables[p].repo == repo)
+	      {
+		if (MAPTST(&donemap, p))
+		  continue;
+	        repodata_search(data, p, SOLVABLE_FILELIST, 0, addfileprovides_cb, cbd);
+		if (!incomplete)
+		  {
+		    MAPSET(&donemap, p);
+		    ndone++;
+		  }
+	      }
+	  map_free(&cbd->useddirs);
+	}
+
+      if (repoonly || ++repoid == pool->nrepos)
+	break;
+      repo = pool->repos[repoid];
+    }
+  map_free(&donemap);
+  queue_free(&fileprovidesq);
+  map_free(&cbd->providedids);
+  if (cbd->dirs)
+    {
+      for (i = 0; i < cbd->nfiles; i++)
+	solv_free(cbd->dirs[i]);
+      cbd->dirs = solv_free(cbd->dirs);
+      cbd->names = solv_free(cbd->names);
+    }
+}
+
+void
+pool_addfileprovides_queue(Pool *pool, Queue *idq, Queue *idqinst)
+{
+  Solvable *s;
+  Repo *installed, *repo;
+  struct searchfiles sf, isf, *isfp;
+  struct addfileprovides_cbdata cbd;
+  int i;
+  unsigned int now;
+
+  installed = pool->installed;
+  now = solv_timems(0);
+  memset(&sf, 0, sizeof(sf));
+  map_init(&sf.seen, pool->ss.nstrings + pool->nrels);
+  memset(&isf, 0, sizeof(isf));
+  map_init(&isf.seen, pool->ss.nstrings + pool->nrels);
+  pool->addedfileprovides = pool->addfileprovidesfiltered ? 1 : 2;
+
+  if (idq)
+    queue_empty(idq);
+  if (idqinst)
+    queue_empty(idqinst);
+  isfp = installed ? &isf : 0;
+  for (i = 1, s = pool->solvables + i; i < pool->nsolvables; i++, s++)
+    {
+      repo = s->repo;
+      if (!repo)
+	continue;
+      if (s->obsoletes)
+        pool_addfileprovides_dep(pool, repo->idarraydata + s->obsoletes, &sf, isfp);
+      if (s->conflicts)
+        pool_addfileprovides_dep(pool, repo->idarraydata + s->conflicts, &sf, isfp);
+      if (s->requires)
+        pool_addfileprovides_dep(pool, repo->idarraydata + s->requires, &sf, isfp);
+      if (s->recommends)
+        pool_addfileprovides_dep(pool, repo->idarraydata + s->recommends, &sf, isfp);
+      if (s->suggests)
+        pool_addfileprovides_dep(pool, repo->idarraydata + s->suggests, &sf, isfp);
+      if (s->supplements)
+        pool_addfileprovides_dep(pool, repo->idarraydata + s->supplements, &sf, isfp);
+      if (s->enhances)
+        pool_addfileprovides_dep(pool, repo->idarraydata + s->enhances, &sf, isfp);
+    }
+  map_free(&sf.seen);
+  map_free(&isf.seen);
+  POOL_DEBUG(SOLV_DEBUG_STATS, "found %d file dependencies, %d installed file dependencies\n", sf.nfiles, isf.nfiles);
+  cbd.dids = 0;
+  if (sf.nfiles)
+    {
+#if 0
+      for (i = 0; i < sf.nfiles; i++)
+	POOL_DEBUG(SOLV_DEBUG_STATS, "looking up %s in filelist\n", pool_id2str(pool, sf.ids[i]));
+#endif
+      pool_addfileprovides_search(pool, &cbd, &sf, 0);
+      if (idq)
+        for (i = 0; i < sf.nfiles; i++)
+	  queue_push(idq, sf.ids[i]);
+      if (idqinst)
+        for (i = 0; i < sf.nfiles; i++)
+	  queue_push(idqinst, sf.ids[i]);
+      solv_free(sf.ids);
+    }
+  if (isf.nfiles)
+    {
+#if 0
+      for (i = 0; i < isf.nfiles; i++)
+	POOL_DEBUG(SOLV_DEBUG_STATS, "looking up %s in installed filelist\n", pool_id2str(pool, isf.ids[i]));
+#endif
+      if (installed)
+        pool_addfileprovides_search(pool, &cbd, &isf, installed);
+      if (installed && idqinst)
+        for (i = 0; i < isf.nfiles; i++)
+	  queue_pushunique(idqinst, isf.ids[i]);
+      solv_free(isf.ids);
+    }
+  solv_free(cbd.dids);
+  pool_freewhatprovides(pool);	/* as we have added provides */
+  POOL_DEBUG(SOLV_DEBUG_STATS, "addfileprovides took %d ms\n", solv_timems(now));
+}
+
+void
+pool_addfileprovides(Pool *pool)
+{
+  pool_addfileprovides_queue(pool, 0, 0);
+}
+
diff --git a/src/pool.c b/src/pool.c
index 85932bf..34fd787 100644
--- a/src/pool.c
+++ b/src/pool.c
@@ -1412,357 +1412,6 @@ void pool_setnamespacecallback(Pool *pool, Id (*cb)(struct _Pool *, void *, Id,
   pool->nscallbackdata = nscbdata;
 }
 
-/*************************************************************************/
-
-struct searchfiles {
-  Id *ids;
-  int nfiles;
-  Map seen;
-};
-
-#define SEARCHFILES_BLOCK 127
-
-static void
-pool_addfileprovides_dep(Pool *pool, Id *ida, struct searchfiles *sf, struct searchfiles *isf)
-{
-  Id dep, sid;
-  const char *s;
-  struct searchfiles *csf;
-
-  while ((dep = *ida++) != 0)
-    {
-      csf = sf;
-      while (ISRELDEP(dep))
-	{
-	  Reldep *rd;
-	  sid = pool->ss.nstrings + GETRELID(dep);
-	  if (MAPTST(&csf->seen, sid))
-	    {
-	      dep = 0;
-	      break;
-	    }
-	  MAPSET(&csf->seen, sid);
-	  rd = GETRELDEP(pool, dep);
-	  if (rd->flags < 8)
-	    dep = rd->name;
-	  else if (rd->flags == REL_NAMESPACE)
-	    {
-	      if (rd->name == NAMESPACE_SPLITPROVIDES)
-		{
-		  csf = isf;
-		  if (!csf || MAPTST(&csf->seen, sid))
-		    {
-		      dep = 0;
-		      break;
-		    }
-		  MAPSET(&csf->seen, sid);
-		}
-	      dep = rd->evr;
-	    }
-	  else if (rd->flags == REL_FILECONFLICT)
-	    {
-	      dep = 0;
-	      break;
-	    }
-	  else
-	    {
-	      Id ids[2];
-	      ids[0] = rd->name;
-	      ids[1] = 0;
-	      pool_addfileprovides_dep(pool, ids, csf, isf);
-	      dep = rd->evr;
-	    }
-	}
-      if (!dep)
-	continue;
-      if (MAPTST(&csf->seen, dep))
-	continue;
-      MAPSET(&csf->seen, dep);
-      s = pool_id2str(pool, dep);
-      if (*s != '/')
-	continue;
-      if (csf != isf && pool->addedfileprovides == 1 && !repodata_filelistfilter_matches(0, s))
-	continue;	/* skip non-standard locations csf == isf: installed case */
-      csf->ids = solv_extend(csf->ids, csf->nfiles, 1, sizeof(Id), SEARCHFILES_BLOCK);
-      csf->ids[csf->nfiles++] = dep;
-    }
-}
-
-struct addfileprovides_cbdata {
-  int nfiles;
-  Id *ids;
-  char **dirs;
-  char **names;
-
-  Id *dids;
-
-  Map providedids;
-
-  Map useddirs;
-};
-
-static int
-addfileprovides_cb(void *cbdata, Solvable *s, Repodata *data, Repokey *key, KeyValue *value)
-{
-  struct addfileprovides_cbdata *cbd = cbdata;
-  int i;
-
-  if (!cbd->useddirs.size)
-    {
-      map_init(&cbd->useddirs, data->dirpool.ndirs + 1);
-      if (!cbd->dirs)
-	{
-	  cbd->dirs = solv_malloc2(cbd->nfiles, sizeof(char *));
-	  cbd->names = solv_malloc2(cbd->nfiles, sizeof(char *));
-	  for (i = 0; i < cbd->nfiles; i++)
-	    {
-	      char *s = solv_strdup(pool_id2str(data->repo->pool, cbd->ids[i]));
-	      cbd->dirs[i] = s;
-	      s = strrchr(s, '/');
-	      *s = 0;
-	      cbd->names[i] = s + 1;
-	    }
-	}
-      for (i = 0; i < cbd->nfiles; i++)
-	{
-	  Id did;
-	  if (MAPTST(&cbd->providedids, cbd->ids[i]))
-	    {
-	      cbd->dids[i] = 0;
-	      continue;
-	    }
-	  did = repodata_str2dir(data, cbd->dirs[i], 0);
-	  cbd->dids[i] = did;
-	  if (did)
-	    MAPSET(&cbd->useddirs, did);
-	}
-      repodata_free_dircache(data);
-    }
-  if (value->id >= data->dirpool.ndirs || !MAPTST(&cbd->useddirs, value->id))
-    return 0;
-  for (i = 0; i < cbd->nfiles; i++)
-    if (cbd->dids[i] == value->id && !strcmp(cbd->names[i], value->str))
-      s->provides = repo_addid_dep(s->repo, s->provides, cbd->ids[i], SOLVABLE_FILEMARKER);
-  return 0;
-}
-
-static void
-pool_addfileprovides_search(Pool *pool, struct addfileprovides_cbdata *cbd, struct searchfiles *sf, Repo *repoonly)
-{
-  Id p;
-  Repodata *data;
-  Repo *repo;
-  Queue fileprovidesq;
-  int i, j, repoid, repodataid;
-  int provstart, provend;
-  Map donemap;
-  int ndone, incomplete;
-
-  if (!pool->urepos)
-    return;
-
-  cbd->nfiles = sf->nfiles;
-  cbd->ids = sf->ids;
-  cbd->dirs = 0;
-  cbd->names = 0;
-  cbd->dids = solv_realloc2(cbd->dids, sf->nfiles, sizeof(Id));
-  map_init(&cbd->providedids, pool->ss.nstrings);
-
-  repoid = 1;
-  repo = repoonly ? repoonly : pool->repos[repoid];
-  map_init(&donemap, pool->nsolvables);
-  queue_init(&fileprovidesq);
-  provstart = provend = 0;
-  for (;;)
-    {
-      if (!repo || repo->disabled)
-	{
-	  if (repoonly || ++repoid == pool->nrepos)
-	    break;
-	  repo = pool->repos[repoid];
-	  continue;
-	}
-      ndone = 0;
-      FOR_REPODATAS(repo, repodataid, data)
-	{
-	  if (ndone >= repo->nsolvables)
-	    break;
-
-	  if (repodata_lookup_idarray(data, SOLVID_META, REPOSITORY_ADDEDFILEPROVIDES, &fileprovidesq))
-	    {
-	      map_empty(&cbd->providedids);
-	      for (i = 0; i < fileprovidesq.count; i++)
-		MAPSET(&cbd->providedids, fileprovidesq.elements[i]);
-	      provstart = data->start;
-	      provend = data->end;
-	      for (i = 0; i < cbd->nfiles; i++)
-		if (!MAPTST(&cbd->providedids, cbd->ids[i]))
-		  break;
-	      if (i == cbd->nfiles)
-		{
-		  /* great! no need to search files */
-		  for (p = data->start; p < data->end; p++)
-		    if (pool->solvables[p].repo == repo)
-		      {
-			if (MAPTST(&donemap, p))
-			  continue;
-			MAPSET(&donemap, p);
-			ndone++;
-		      }
-		  continue;
-		}
-	    }
-
-	  if (!repodata_has_keyname(data, SOLVABLE_FILELIST))
-	    continue;
-
-	  if (data->start < provstart || data->end > provend)
-	    {
-	      map_empty(&cbd->providedids);
-	      provstart = provend = 0;
-	    }
-
-	  /* check if the data is incomplete */
-	  incomplete = 0;
-	  if (data->state == REPODATA_AVAILABLE)
-	    {
-	      for (j = 1; j < data->nkeys; j++)
-		if (data->keys[j].name != REPOSITORY_SOLVABLES && data->keys[j].name != SOLVABLE_FILELIST)
-		  break;
-	      if (j < data->nkeys)
-		{
-#if 0
-		  for (i = 0; i < cbd->nfiles; i++)
-		    if (!MAPTST(&cbd->providedids, cbd->ids[i]) && !repodata_filelistfilter_matches(data, pool_id2str(pool, cbd->ids[i])))
-		      printf("need complete filelist because of %s\n", pool_id2str(pool, cbd->ids[i]));
-#endif
-		  for (i = 0; i < cbd->nfiles; i++)
-		    if (!MAPTST(&cbd->providedids, cbd->ids[i]) && !repodata_filelistfilter_matches(data, pool_id2str(pool, cbd->ids[i])))
-		      break;
-		  if (i < cbd->nfiles)
-		    incomplete = 1;
-		}
-	    }
-
-	  /* do the search */
-	  map_init(&cbd->useddirs, 0);
-	  for (p = data->start; p < data->end; p++)
-	    if (pool->solvables[p].repo == repo)
-	      {
-		if (MAPTST(&donemap, p))
-		  continue;
-	        repodata_search(data, p, SOLVABLE_FILELIST, 0, addfileprovides_cb, cbd);
-		if (!incomplete)
-		  {
-		    MAPSET(&donemap, p);
-		    ndone++;
-		  }
-	      }
-	  map_free(&cbd->useddirs);
-	}
-
-      if (repoonly || ++repoid == pool->nrepos)
-	break;
-      repo = pool->repos[repoid];
-    }
-  map_free(&donemap);
-  queue_free(&fileprovidesq);
-  map_free(&cbd->providedids);
-  if (cbd->dirs)
-    {
-      for (i = 0; i < cbd->nfiles; i++)
-	solv_free(cbd->dirs[i]);
-      cbd->dirs = solv_free(cbd->dirs);
-      cbd->names = solv_free(cbd->names);
-    }
-}
-
-void
-pool_addfileprovides_queue(Pool *pool, Queue *idq, Queue *idqinst)
-{
-  Solvable *s;
-  Repo *installed, *repo;
-  struct searchfiles sf, isf, *isfp;
-  struct addfileprovides_cbdata cbd;
-  int i;
-  unsigned int now;
-
-  installed = pool->installed;
-  now = solv_timems(0);
-  memset(&sf, 0, sizeof(sf));
-  map_init(&sf.seen, pool->ss.nstrings + pool->nrels);
-  memset(&isf, 0, sizeof(isf));
-  map_init(&isf.seen, pool->ss.nstrings + pool->nrels);
-  pool->addedfileprovides = pool->addfileprovidesfiltered ? 1 : 2;
-
-  if (idq)
-    queue_empty(idq);
-  if (idqinst)
-    queue_empty(idqinst);
-  isfp = installed ? &isf : 0;
-  for (i = 1, s = pool->solvables + i; i < pool->nsolvables; i++, s++)
-    {
-      repo = s->repo;
-      if (!repo)
-	continue;
-      if (s->obsoletes)
-        pool_addfileprovides_dep(pool, repo->idarraydata + s->obsoletes, &sf, isfp);
-      if (s->conflicts)
-        pool_addfileprovides_dep(pool, repo->idarraydata + s->conflicts, &sf, isfp);
-      if (s->requires)
-        pool_addfileprovides_dep(pool, repo->idarraydata + s->requires, &sf, isfp);
-      if (s->recommends)
-        pool_addfileprovides_dep(pool, repo->idarraydata + s->recommends, &sf, isfp);
-      if (s->suggests)
-        pool_addfileprovides_dep(pool, repo->idarraydata + s->suggests, &sf, isfp);
-      if (s->supplements)
-        pool_addfileprovides_dep(pool, repo->idarraydata + s->supplements, &sf, isfp);
-      if (s->enhances)
-        pool_addfileprovides_dep(pool, repo->idarraydata + s->enhances, &sf, isfp);
-    }
-  map_free(&sf.seen);
-  map_free(&isf.seen);
-  POOL_DEBUG(SOLV_DEBUG_STATS, "found %d file dependencies, %d installed file dependencies\n", sf.nfiles, isf.nfiles);
-  cbd.dids = 0;
-  if (sf.nfiles)
-    {
-#if 0
-      for (i = 0; i < sf.nfiles; i++)
-	POOL_DEBUG(SOLV_DEBUG_STATS, "looking up %s in filelist\n", pool_id2str(pool, sf.ids[i]));
-#endif
-      pool_addfileprovides_search(pool, &cbd, &sf, 0);
-      if (idq)
-        for (i = 0; i < sf.nfiles; i++)
-	  queue_push(idq, sf.ids[i]);
-      if (idqinst)
-        for (i = 0; i < sf.nfiles; i++)
-	  queue_push(idqinst, sf.ids[i]);
-      solv_free(sf.ids);
-    }
-  if (isf.nfiles)
-    {
-#if 0
-      for (i = 0; i < isf.nfiles; i++)
-	POOL_DEBUG(SOLV_DEBUG_STATS, "looking up %s in installed filelist\n", pool_id2str(pool, isf.ids[i]));
-#endif
-      if (installed)
-        pool_addfileprovides_search(pool, &cbd, &isf, installed);
-      if (installed && idqinst)
-        for (i = 0; i < isf.nfiles; i++)
-	  queue_pushunique(idqinst, isf.ids[i]);
-      solv_free(isf.ids);
-    }
-  solv_free(cbd.dids);
-  pool_freewhatprovides(pool);	/* as we have added provides */
-  POOL_DEBUG(SOLV_DEBUG_STATS, "addfileprovides took %d ms\n", solv_timems(now));
-}
-
-void
-pool_addfileprovides(Pool *pool)
-{
-  pool_addfileprovides_queue(pool, 0, 0);
-}
-
 void
 pool_search(Pool *pool, Id p, Id key, const char *match, int flags, int (*callback)(void *cbdata, Solvable *s, struct _Repodata *data, struct _Repokey *key, struct _KeyValue *kv), void *cbdata)
 {
@@ -1784,7 +1433,6 @@ pool_clear_pos(Pool *pool)
   memset(&pool->pos, 0, sizeof(pool->pos));
 }
 
-
 void
 pool_set_languages(Pool *pool, const char **languages, int nlanguages)
 {
@@ -1951,330 +1599,6 @@ pool_bin2hex(Pool *pool, const unsigned char *buf, int len)
   return s;
 }
 
-/*******************************************************************/
-
-struct mptree {
-  Id sibling;
-  Id child;
-  const char *comp;
-  int compl;
-  Id mountpoint;
-};
-
-struct ducbdata {
-  DUChanges *mps;
-  struct mptree *mptree;
-  int addsub;
-  int hasdu;
-
-  Id *dirmap;
-  int nmap;
-  Repodata *olddata;
-};
-
-
-static int
-solver_fill_DU_cb(void *cbdata, Solvable *s, Repodata *data, Repokey *key, KeyValue *value)
-{
-  struct ducbdata *cbd = cbdata;
-  Id mp;
-
-  if (data != cbd->olddata)
-    {
-      Id dn, mp, comp, *dirmap, *dirs;
-      int i, compl;
-      const char *compstr;
-      struct mptree *mptree;
-
-      /* create map from dir to mptree */
-      cbd->dirmap = solv_free(cbd->dirmap);
-      cbd->nmap = 0;
-      dirmap = solv_calloc(data->dirpool.ndirs, sizeof(Id));
-      mptree = cbd->mptree;
-      mp = 0;
-      for (dn = 2, dirs = data->dirpool.dirs + dn; dn < data->dirpool.ndirs; dn++)
-	{
-	  comp = *dirs++;
-	  if (comp <= 0)
-	    {
-	      mp = dirmap[-comp];
-	      continue;
-	    }
-	  if (mp < 0)
-	    {
-	      /* unconnected */
-	      dirmap[dn] = mp;
-	      continue;
-	    }
-	  if (!mptree[mp].child)
-	    {
-	      dirmap[dn] = -mp;
-	      continue;
-	    }
-	  if (data->localpool)
-	    compstr = stringpool_id2str(&data->spool, comp);
-	  else
-	    compstr = pool_id2str(data->repo->pool, comp);
-	  compl = strlen(compstr);
-	  for (i = mptree[mp].child; i; i = mptree[i].sibling)
-	    if (mptree[i].compl == compl && !strncmp(mptree[i].comp, compstr, compl))
-	      break;
-	  dirmap[dn] = i ? i : -mp;
-	}
-      /* change dirmap to point to mountpoint instead of mptree */
-      for (dn = 0; dn < data->dirpool.ndirs; dn++)
-	{
-	  mp = dirmap[dn];
-	  dirmap[dn] = mptree[mp > 0 ? mp : -mp].mountpoint;
-	}
-      cbd->dirmap = dirmap;
-      cbd->nmap = data->dirpool.ndirs;
-      cbd->olddata = data;
-    }
-  cbd->hasdu = 1;
-  if (value->id < 0 || value->id >= cbd->nmap)
-    return 0;
-  mp = cbd->dirmap[value->id];
-  if (mp < 0)
-    return 0;
-  if (cbd->addsub > 0)
-    {
-      cbd->mps[mp].kbytes += value->num;
-      cbd->mps[mp].files += value->num2;
-    }
-  else if (!(cbd->mps[mp].flags & DUCHANGES_ONLYADD))
-    {
-      cbd->mps[mp].kbytes -= value->num;
-      cbd->mps[mp].files -= value->num2;
-    }
-  return 0;
-}
-
-static void
-propagate_mountpoints(struct mptree *mptree, int pos, Id mountpoint)
-{
-  int i;
-  if (mptree[pos].mountpoint == -1)
-    mptree[pos].mountpoint = mountpoint;
-  else
-    mountpoint = mptree[pos].mountpoint;
-  for (i = mptree[pos].child; i; i = mptree[i].sibling)
-    propagate_mountpoints(mptree, i, mountpoint);
-}
-
-#define MPTREE_BLOCK 15
-
-static struct mptree *
-create_mptree(DUChanges *mps, int nmps)
-{
-  int i, nmptree;
-  struct mptree *mptree;
-  int pos, compl;
-  int mp;
-  const char *p, *path, *compstr;
-
-  mptree = solv_extend_resize(0, 1, sizeof(struct mptree), MPTREE_BLOCK);
-
-  /* our root node */
-  mptree[0].sibling = 0;
-  mptree[0].child = 0;
-  mptree[0].comp = 0;
-  mptree[0].compl = 0;
-  mptree[0].mountpoint = -1;
-  nmptree = 1;
-
-  /* create component tree */
-  for (mp = 0; mp < nmps; mp++)
-    {
-      mps[mp].kbytes = 0;
-      mps[mp].files = 0;
-      pos = 0;
-      path = mps[mp].path;
-      while(*path == '/')
-	path++;
-      while (*path)
-	{
-	  if ((p = strchr(path, '/')) == 0)
-	    {
-	      compstr = path;
-	      compl = strlen(compstr);
-	      path += compl;
-	    }
-	  else
-	    {
-	      compstr = path;
-	      compl = p - path;
-	      path = p + 1;
-	      while(*path == '/')
-		path++;
-	    }
-          for (i = mptree[pos].child; i; i = mptree[i].sibling)
-	    if (mptree[i].compl == compl && !strncmp(mptree[i].comp, compstr, compl))
-	      break;
-	  if (!i)
-	    {
-	      /* create new node */
-	      mptree = solv_extend(mptree, nmptree, 1, sizeof(struct mptree), MPTREE_BLOCK);
-	      i = nmptree++;
-	      mptree[i].sibling = mptree[pos].child;
-	      mptree[i].child = 0;
-	      mptree[i].comp = compstr;
-	      mptree[i].compl = compl;
-	      mptree[i].mountpoint = -1;
-	      mptree[pos].child = i;
-	    }
-	  pos = i;
-	}
-      mptree[pos].mountpoint = mp;
-    }
-
-  propagate_mountpoints(mptree, 0, mptree[0].mountpoint);
-
-#if 0
-  for (i = 0; i < nmptree; i++)
-    {
-      printf("#%d sibling: %d\n", i, mptree[i].sibling);
-      printf("#%d child: %d\n", i, mptree[i].child);
-      printf("#%d comp: %s\n", i, mptree[i].comp);
-      printf("#%d compl: %d\n", i, mptree[i].compl);
-      printf("#%d mountpont: %d\n", i, mptree[i].mountpoint);
-    }
-#endif
-
-  return mptree;
-}
-
-void
-pool_calc_duchanges(Pool *pool, Map *installedmap, DUChanges *mps, int nmps)
-{
-  struct mptree *mptree;
-  struct ducbdata cbd;
-  Solvable *s;
-  int i, sp;
-  Map ignoredu;
-  Repo *oldinstalled = pool->installed;
-  int haveonlyadd = 0;
-
-  map_init(&ignoredu, 0);
-  mptree = create_mptree(mps, nmps);
-
-  for (i = 0; i < nmps; i++)
-    if ((mps[i].flags & DUCHANGES_ONLYADD) != 0)
-      haveonlyadd = 1;
-  cbd.mps = mps;
-  cbd.dirmap = 0;
-  cbd.nmap = 0;
-  cbd.olddata = 0;
-  cbd.mptree = mptree;
-  cbd.addsub = 1;
-  for (sp = 1, s = pool->solvables + sp; sp < pool->nsolvables; sp++, s++)
-    {
-      if (!s->repo || (oldinstalled && s->repo == oldinstalled))
-	continue;
-      if (!MAPTST(installedmap, sp))
-	continue;
-      cbd.hasdu = 0;
-      repo_search(s->repo, sp, SOLVABLE_DISKUSAGE, 0, 0, solver_fill_DU_cb, &cbd);
-      if (!cbd.hasdu && oldinstalled)
-	{
-	  Id op, opp;
-	  int didonlyadd = 0;
-	  /* no du data available, ignore data of all installed solvables we obsolete */
-	  if (!ignoredu.size)
-	    map_grow(&ignoredu, oldinstalled->end - oldinstalled->start);
-	  FOR_PROVIDES(op, opp, s->name)
-	    {
-	      Solvable *s2 = pool->solvables + op;
-	      if (!pool->implicitobsoleteusesprovides && s->name != s2->name)
-		continue;
-	      if (pool->implicitobsoleteusescolors && !pool_colormatch(pool, s, s2))
-		continue;
-	      if (op >= oldinstalled->start && op < oldinstalled->end)
-		{
-		  MAPSET(&ignoredu, op - oldinstalled->start);
-		  if (haveonlyadd && pool->solvables[op].repo == oldinstalled && !didonlyadd)
-		    {
-		      repo_search(oldinstalled, op, SOLVABLE_DISKUSAGE, 0, 0, solver_fill_DU_cb, &cbd);
-		      cbd.addsub = -1;
-		      repo_search(oldinstalled, op, SOLVABLE_DISKUSAGE, 0, 0, solver_fill_DU_cb, &cbd);
-		      cbd.addsub = 1;
-		      didonlyadd = 1;
-		    }
-		}
-	    }
-	  if (s->obsoletes)
-	    {
-	      Id obs, *obsp = s->repo->idarraydata + s->obsoletes;
-	      while ((obs = *obsp++) != 0)
-		FOR_PROVIDES(op, opp, obs)
-		  {
-		    Solvable *s2 = pool->solvables + op;
-		    if (!pool->obsoleteusesprovides && !pool_match_nevr(pool, s2, obs))
-		      continue;
-		    if (pool->obsoleteusescolors && !pool_colormatch(pool, s, s2))
-		      continue;
-		    if (op >= oldinstalled->start && op < oldinstalled->end)
-		      {
-			MAPSET(&ignoredu, op - oldinstalled->start);
-			if (haveonlyadd && pool->solvables[op].repo == oldinstalled && !didonlyadd)
-			  {
-			    repo_search(oldinstalled, op, SOLVABLE_DISKUSAGE, 0, 0, solver_fill_DU_cb, &cbd);
-			    cbd.addsub = -1;
-			    repo_search(oldinstalled, op, SOLVABLE_DISKUSAGE, 0, 0, solver_fill_DU_cb, &cbd);
-			    cbd.addsub = 1;
-			    didonlyadd = 1;
-			  }
-		      }
-		  }
-	    }
-	}
-    }
-  cbd.addsub = -1;
-  if (oldinstalled)
-    {
-      /* assumes we allways have du data for installed solvables */
-      FOR_REPO_SOLVABLES(oldinstalled, sp, s)
-	{
-	  if (MAPTST(installedmap, sp))
-	    continue;
-	  if (ignoredu.map && MAPTST(&ignoredu, sp - oldinstalled->start))
-	    continue;
-	  repo_search(oldinstalled, sp, SOLVABLE_DISKUSAGE, 0, 0, solver_fill_DU_cb, &cbd);
-	}
-    }
-  map_free(&ignoredu);
-  solv_free(cbd.dirmap);
-  solv_free(mptree);
-}
-
-int
-pool_calc_installsizechange(Pool *pool, Map *installedmap)
-{
-  Id sp;
-  Solvable *s;
-  int change = 0;
-  Repo *oldinstalled = pool->installed;
-
-  for (sp = 1, s = pool->solvables + sp; sp < pool->nsolvables; sp++, s++)
-    {
-      if (!s->repo || (oldinstalled && s->repo == oldinstalled))
-	continue;
-      if (!MAPTST(installedmap, sp))
-	continue;
-      change += solvable_lookup_sizek(s, SOLVABLE_INSTALLSIZE, 0);
-    }
-  if (oldinstalled)
-    {
-      FOR_REPO_SOLVABLES(oldinstalled, sp, s)
-	{
-	  if (MAPTST(installedmap, sp))
-	    continue;
-	  change -= solvable_lookup_sizek(s, SOLVABLE_INSTALLSIZE, 0);
-	}
-    }
-  return change;
-}
-
 /* map:
  *  1: installed
  *  2: conflicts with installed
-- 
2.5.0

